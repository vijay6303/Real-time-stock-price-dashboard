"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/stock/[symbol]",{

/***/ "./lib/utils.ts":
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateChange: function() { return /* binding */ calculateChange; },\n/* harmony export */   cn: function() { return /* binding */ cn; },\n/* harmony export */   formatCurrency: function() { return /* binding */ formatCurrency; },\n/* harmony export */   formatDate: function() { return /* binding */ formatDate; },\n/* harmony export */   formatPercentage: function() { return /* binding */ formatPercentage; },\n/* harmony export */   formatTime: function() { return /* binding */ formatTime; },\n/* harmony export */   formatTimeForDisplay: function() { return /* binding */ formatTimeForDisplay; },\n/* harmony export */   formatVolume: function() { return /* binding */ formatVolume; },\n/* harmony export */   transformTimeSeriesData: function() { return /* binding */ transformTimeSeriesData; }\n/* harmony export */ });\nfunction formatCurrency(value) {\n    // Handle null, undefined, NaN, and Infinity values\n    if (typeof value !== \"number\" || !isFinite(value)) {\n        return \"$0.00\";\n    }\n    return new Intl.NumberFormat(\"en-US\", {\n        style: \"currency\",\n        currency: \"USD\",\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).format(value);\n}\nfunction formatPercentage(value) {\n    // Handle null, undefined, NaN, and Infinity values\n    if (typeof value !== \"number\" || !isFinite(value)) {\n        return \"+0.00%\";\n    }\n    const sign = value >= 0 ? \"+\" : \"\";\n    return \"\".concat(sign).concat(value.toFixed(2), \"%\");\n}\nfunction formatVolume(value) {\n    // Handle null, undefined, NaN, and Infinity values\n    if (typeof value !== \"number\" || !isFinite(value) || value <= 0) {\n        return \"0\";\n    }\n    if (value >= 1000000000) {\n        return \"\".concat((value / 1000000000).toFixed(2), \"B\");\n    }\n    if (value >= 1000000) {\n        return \"\".concat((value / 1000000).toFixed(2), \"M\");\n    }\n    if (value >= 1000) {\n        return \"\".concat((value / 1000).toFixed(2), \"K\");\n    }\n    return value.toString();\n}\nfunction formatTime(date) {\n    if (!date || !(date instanceof Date) || isNaN(date.getTime())) {\n        return new Date().toLocaleTimeString(\"en-US\", {\n            hour12: true,\n            hour: \"numeric\",\n            minute: \"2-digit\",\n            second: \"2-digit\"\n        });\n    }\n    return date.toLocaleTimeString(\"en-US\", {\n        hour12: true,\n        hour: \"numeric\",\n        minute: \"2-digit\",\n        second: \"2-digit\"\n    });\n}\n// Safe time formatter that prevents hydration mismatches\nfunction formatTimeForDisplay(timestamp) {\n    // For SSR safety, return a placeholder during server render\n    if (false) {}\n    try {\n        const date = timestamp ? new Date(timestamp) : new Date();\n        return date.toLocaleTimeString(\"en-US\", {\n            hour12: true,\n            hour: \"numeric\",\n            minute: \"2-digit\",\n            second: \"2-digit\"\n        });\n    } catch (error) {\n        return \"--:--:-- --\";\n    }\n}\nfunction formatDate(date) {\n    let dateObj;\n    if (typeof date === \"string\") {\n        dateObj = new Date(date);\n    } else if (date instanceof Date) {\n        dateObj = date;\n    } else {\n        dateObj = new Date();\n    }\n    // Check if date is valid\n    if (isNaN(dateObj.getTime())) {\n        dateObj = new Date();\n    }\n    return dateObj.toLocaleDateString(\"en-US\", {\n        month: \"short\",\n        day: \"numeric\"\n    });\n}\nfunction transformTimeSeriesData(data) {\n    // If it's already ChartDataPoint array, return it\n    if (Array.isArray(data)) {\n        return data.length > 0 ? data : [];\n    }\n    if (!data || typeof data !== \"object\") {\n        return [];\n    }\n    try {\n        return Object.entries(data).map((param)=>{\n            let [date, values] = param;\n            // Safely parse values with fallbacks\n            const price = parseFloat((values === null || values === void 0 ? void 0 : values[\"4. close\"]) || \"0\") || 0;\n            const volume = parseInt((values === null || values === void 0 ? void 0 : values[\"5. volume\"]) || \"0\") || 0;\n            return {\n                date: formatDate(date),\n                price,\n                volume\n            };\n        }).filter((item)=>item.price > 0) // Filter out invalid entries\n        .reverse().slice(-30); // Last 30 days\n    } catch (error) {\n        console.error(\"Error transforming time series data:\", error);\n        return [];\n    }\n}\nfunction calculateChange(current, previous) {\n    // Handle invalid inputs\n    if (typeof current !== \"number\" || typeof previous !== \"number\" || !isFinite(current) || !isFinite(previous) || previous === 0) {\n        return {\n            change: 0,\n            changePercent: 0\n        };\n    }\n    const change = current - previous;\n    const changePercent = change / previous * 100;\n    return {\n        change: Math.round(change * 100) / 100,\n        changePercent: Math.round(changePercent * 100) / 100\n    };\n}\nfunction cn() {\n    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){\n        classes[_key] = arguments[_key];\n    }\n    return classes.filter(Boolean).join(\" \");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBRztRQUFHQyxRQUFILHVCQUFtRDtJQUFEO0lBQ25FLE9BQU9BLFFBQVFiLE1BQU0sQ0FBQ2MsU0FBU0MsSUFBSSxDQUFDO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi91dGlscy50cz9mNzQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYXJ0RGF0YVBvaW50LCBUaW1lU2VyaWVzRGF0YSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRDdXJyZW5jeSh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHtcclxuICAvLyBIYW5kbGUgbnVsbCwgdW5kZWZpbmVkLCBOYU4sIGFuZCBJbmZpbml0eSB2YWx1ZXNcclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gJyQwLjAwJztcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7XHJcbiAgICBzdHlsZTogJ2N1cnJlbmN5JyxcclxuICAgIGN1cnJlbmN5OiAnVVNEJyxcclxuICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogMixcclxuICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcclxuICB9KS5mb3JtYXQodmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UGVyY2VudGFnZSh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHtcclxuICAvLyBIYW5kbGUgbnVsbCwgdW5kZWZpbmVkLCBOYU4sIGFuZCBJbmZpbml0eSB2YWx1ZXNcclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gJyswLjAwJSc7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHNpZ24gPSB2YWx1ZSA+PSAwID8gJysnIDogJyc7XHJcbiAgcmV0dXJuIGAke3NpZ259JHt2YWx1ZS50b0ZpeGVkKDIpfSVgO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Vm9sdW1lKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIC8vIEhhbmRsZSBudWxsLCB1bmRlZmluZWQsIE5hTiwgYW5kIEluZmluaXR5IHZhbHVlc1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZSh2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xyXG4gICAgcmV0dXJuICcwJztcclxuICB9XHJcbiAgXHJcbiAgaWYgKHZhbHVlID49IDFfMDAwXzAwMF8wMDApIHtcclxuICAgIHJldHVybiBgJHsodmFsdWUgLyAxXzAwMF8wMDBfMDAwKS50b0ZpeGVkKDIpfUJgO1xyXG4gIH1cclxuICBpZiAodmFsdWUgPj0gMV8wMDBfMDAwKSB7XHJcbiAgICByZXR1cm4gYCR7KHZhbHVlIC8gMV8wMDBfMDAwKS50b0ZpeGVkKDIpfU1gO1xyXG4gIH1cclxuICBpZiAodmFsdWUgPj0gMV8wMDApIHtcclxuICAgIHJldHVybiBgJHsodmFsdWUgLyAxXzAwMCkudG9GaXhlZCgyKX1LYDtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lKGRhdGU6IERhdGUpOiBzdHJpbmcge1xyXG4gIGlmICghZGF0ZSB8fCAhKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB8fCBpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygnZW4tVVMnLCB7XHJcbiAgICAgIGhvdXIxMjogdHJ1ZSxcclxuICAgICAgaG91cjogJ251bWVyaWMnLFxyXG4gICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgc2Vjb25kOiAnMi1kaWdpdCdcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywge1xyXG4gICAgaG91cjEyOiB0cnVlLFxyXG4gICAgaG91cjogJ251bWVyaWMnLFxyXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICBzZWNvbmQ6ICcyLWRpZ2l0J1xyXG4gIH0pO1xyXG59XHJcblxyXG4vLyBTYWZlIHRpbWUgZm9ybWF0dGVyIHRoYXQgcHJldmVudHMgaHlkcmF0aW9uIG1pc21hdGNoZXNcclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWVGb3JEaXNwbGF5KHRpbWVzdGFtcD86IHN0cmluZyB8IERhdGUpOiBzdHJpbmcge1xyXG4gIC8vIEZvciBTU1Igc2FmZXR5LCByZXR1cm4gYSBwbGFjZWhvbGRlciBkdXJpbmcgc2VydmVyIHJlbmRlclxyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgcmV0dXJuICctLTotLTotLSAtLSc7XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBkYXRlID0gdGltZXN0YW1wID8gbmV3IERhdGUodGltZXN0YW1wKSA6IG5ldyBEYXRlKCk7XHJcbiAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywge1xyXG4gICAgICBob3VyMTI6IHRydWUsXHJcbiAgICAgIGhvdXI6ICdudW1lcmljJyxcclxuICAgICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICAgIHNlY29uZDogJzItZGlnaXQnXHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmV0dXJuICctLTotLTotLSAtLSc7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlOiBzdHJpbmcgfCBEYXRlKTogc3RyaW5nIHtcclxuICBsZXQgZGF0ZU9iajogRGF0ZTtcclxuICBcclxuICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBkYXRlT2JqID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgfSBlbHNlIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgZGF0ZU9iaiA9IGRhdGU7XHJcbiAgfSBlbHNlIHtcclxuICAgIGRhdGVPYmogPSBuZXcgRGF0ZSgpO1xyXG4gIH1cclxuICBcclxuICAvLyBDaGVjayBpZiBkYXRlIGlzIHZhbGlkXHJcbiAgaWYgKGlzTmFOKGRhdGVPYmouZ2V0VGltZSgpKSkge1xyXG4gICAgZGF0ZU9iaiA9IG5ldyBEYXRlKCk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBkYXRlT2JqLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7IFxyXG4gICAgbW9udGg6ICdzaG9ydCcsIFxyXG4gICAgZGF5OiAnbnVtZXJpYycgXHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1UaW1lU2VyaWVzRGF0YShkYXRhOiBUaW1lU2VyaWVzRGF0YSB8IENoYXJ0RGF0YVBvaW50W10pOiBDaGFydERhdGFQb2ludFtdIHtcclxuICAvLyBJZiBpdCdzIGFscmVhZHkgQ2hhcnREYXRhUG9pbnQgYXJyYXksIHJldHVybiBpdFxyXG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gZGF0YSA6IFtdO1xyXG4gIH1cclxuICBcclxuICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSlcclxuICAgICAgLm1hcCgoW2RhdGUsIHZhbHVlc10pID0+IHtcclxuICAgICAgICAvLyBTYWZlbHkgcGFyc2UgdmFsdWVzIHdpdGggZmFsbGJhY2tzXHJcbiAgICAgICAgY29uc3QgcHJpY2UgPSBwYXJzZUZsb2F0KHZhbHVlcz8uWyc0LiBjbG9zZSddIHx8ICcwJykgfHwgMDtcclxuICAgICAgICBjb25zdCB2b2x1bWUgPSBwYXJzZUludCh2YWx1ZXM/LlsnNS4gdm9sdW1lJ10gfHwgJzAnKSB8fCAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBkYXRlOiBmb3JtYXREYXRlKGRhdGUpLFxyXG4gICAgICAgICAgcHJpY2UsXHJcbiAgICAgICAgICB2b2x1bWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgfSlcclxuICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0ucHJpY2UgPiAwKSAvLyBGaWx0ZXIgb3V0IGludmFsaWQgZW50cmllc1xyXG4gICAgICAucmV2ZXJzZSgpXHJcbiAgICAgIC5zbGljZSgtMzApOyAvLyBMYXN0IDMwIGRheXNcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdHJhbnNmb3JtaW5nIHRpbWUgc2VyaWVzIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNoYW5nZShjdXJyZW50OiBudW1iZXIsIHByZXZpb3VzOiBudW1iZXIpOiB7IGNoYW5nZTogbnVtYmVyOyBjaGFuZ2VQZXJjZW50OiBudW1iZXIgfSB7XHJcbiAgLy8gSGFuZGxlIGludmFsaWQgaW5wdXRzXHJcbiAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJldmlvdXMgIT09ICdudW1iZXInIHx8IFxyXG4gICAgICAhaXNGaW5pdGUoY3VycmVudCkgfHwgIWlzRmluaXRlKHByZXZpb3VzKSB8fCBwcmV2aW91cyA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHsgY2hhbmdlOiAwLCBjaGFuZ2VQZXJjZW50OiAwIH07XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IGNoYW5nZSA9IGN1cnJlbnQgLSBwcmV2aW91cztcclxuICBjb25zdCBjaGFuZ2VQZXJjZW50ID0gKGNoYW5nZSAvIHByZXZpb3VzKSAqIDEwMDtcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgY2hhbmdlOiBNYXRoLnJvdW5kKGNoYW5nZSAqIDEwMCkgLyAxMDAsXHJcbiAgICBjaGFuZ2VQZXJjZW50OiBNYXRoLnJvdW5kKGNoYW5nZVBlcmNlbnQgKiAxMDApIC8gMTAwLFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjbiguLi5jbGFzc2VzOiAoc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCB8IGJvb2xlYW4pW10pOiBzdHJpbmcge1xyXG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJyk7XHJcbn1cclxuIl0sIm5hbWVzIjpbImZvcm1hdEN1cnJlbmN5IiwidmFsdWUiLCJpc0Zpbml0ZSIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJzdHlsZSIsImN1cnJlbmN5IiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwiZm9ybWF0IiwiZm9ybWF0UGVyY2VudGFnZSIsInNpZ24iLCJ0b0ZpeGVkIiwiZm9ybWF0Vm9sdW1lIiwidG9TdHJpbmciLCJmb3JtYXRUaW1lIiwiZGF0ZSIsIkRhdGUiLCJpc05hTiIsImdldFRpbWUiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyMTIiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiZm9ybWF0VGltZUZvckRpc3BsYXkiLCJ0aW1lc3RhbXAiLCJlcnJvciIsImZvcm1hdERhdGUiLCJkYXRlT2JqIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwibW9udGgiLCJkYXkiLCJ0cmFuc2Zvcm1UaW1lU2VyaWVzRGF0YSIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwidmFsdWVzIiwicHJpY2UiLCJwYXJzZUZsb2F0Iiwidm9sdW1lIiwicGFyc2VJbnQiLCJmaWx0ZXIiLCJpdGVtIiwicmV2ZXJzZSIsInNsaWNlIiwiY29uc29sZSIsImNhbGN1bGF0ZUNoYW5nZSIsImN1cnJlbnQiLCJwcmV2aW91cyIsImNoYW5nZSIsImNoYW5nZVBlcmNlbnQiLCJNYXRoIiwicm91bmQiLCJjbiIsImNsYXNzZXMiLCJCb29sZWFuIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/utils.ts\n"));

/***/ })

});